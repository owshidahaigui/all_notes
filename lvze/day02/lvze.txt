1.  python2 和 python3 差异

    * python3 语法上还是规范上优于python2

    * 函数差异

      print  
      python2 中是关键字   print "hello world"
      python3 中是函数      	

      input
      python2 中有 input() 和 raw_input()
      python3 中只有input()

      range
      python2 中有range得到列表  xrange得到迭代器
      python3 中只有range 得到一个迭代器

      python3中内建函数多了一些，super()

    * 编码格式的差异

      python2 默认编码格式是ascii 
      如果使用中文需加： #! coding=utf-8 
                         #! -*- coding=utf-8 -*-

      python3 默认编码为utf-8,并且python3 中引入字节串

    * 运算修改

      python2   中  3 / 2 =》1 3.0 / 2 => 1.5,
                地板除方法与python3相同
      python3  中废除了<>这种不等于

    * 数据类型差异

      python3中引入字节串
      python3 废除了python2 中的long类型，python3中只有int相当于python2的long

    * 关键字修改

      python3 将True False变为关键字

      引入了nonlocal关键字

    * 语法变化

      异常 ：python2中异常和异常对象逗号分开
             except Exception ,e

      python2中 tab和四个空格等价

      python3 引入了协程等语法规则

    * 库的变化

      * 标准库库名根符合pep8 
        SocketServer --》 socketserver

2.  深拷贝，浅拷贝
    
    * 对于不可变类型，浅拷贝复制的是地址指向，不开辟新空间
    * 对于可变类型，浅拷贝会复制开辟新的空间，但是只复制最顶层空间内容
    * 浅拷贝后，改变一个对象中可变类型的值，另外一个对象也受影响，改变一个对象中不可变类型的值，另一个不受影响
    * 深拷其实是浅拷贝的递归做法，拷贝后，所有内容均被拷贝，相互不影响

3.  python是一个什么样的编程语言
    
    面向对象 

        机器语言 -> 汇编语言（低级语言） -> 高级语言（面向对象，面向过程） 

        面向过程 ： 以步骤（语句）为核心
        面向对象 ： 以数据为核心

    解释型语言

        编译型 ：有先编译的过程 -》（目标文件）
        解释型 : 靠解释器直接解释执行
        半编译半解释

    脚本语言 

        语法简单，用它做在自动化，或者辅助程序中使用

    动态语言 

        动态语言 ： 在标识符的赋值上不体现类型，具体类型根据赋的值而定。

        静态语言 ： 在定义标识符的时候直接需要指明标识符类型，并且不能改变。静态语言往往可以提前开辟空间，所以效率较高  
    
    强类型

        强类型：不允许变量在运算或者语句操作过程中隐式的进行类型转换

        弱类型：允许变量在执行中隐式的转换类型

4.  装饰器 （语法糖）
    
    函数 装饰 类
    函数 装饰 函数  （最常用）
    类 装饰 类
    类 装饰 函数

    闭包 ： 引用了自由变量的函数，自由变量会与函数同在，即使已经离开了创造他们的环境

    装饰的函数为固定参数

    装饰的函数为不定参数

    装饰器带参数

5.  类中的魔法方法 （ 前后有双下划线 __fun__() ）

6.  静态方法，类方法，多继承规则，元类
    
    * 类方法和静态方法都可以使用类和实例对象调用，但是更希望通过类直接调用

    * 类方法和静态方法是伴随类的加载加载的

    * 静态方法更多些类的独立的逻辑部分

    * 类方法多一个cls，更方便对类的属性修改，和继承中差异化处理

    * 应该尽量避免多继承，如果多继承出现，遵循mro算法的继承优先级关系

    * 元类 type : 创建类的类

7.  Linux 操作系统
    
    * 服务器上的操作系统就是Linux（纯净版），如果购买云服务要使用ssh登录

    * Linux 命令

       uname -r  查看内核版本

       打开终端  ctrl alt + t 
                 ctrl shift + n 
                 chrl shift + t  (alt 加 数字切换)

       退出 ： exit

       软件包

    	 dpkg -i [package]  安装
    	 dpkg -r [package]  删除

    	 apt-get install [app]  安装
    	 apt-get update 更新软件源
    	 apt-get remove --purge [app]  卸载

    	 软件包位置 
    	 /var/cache/apt/archives
         
         软件源
         /etc/apt/sources.list

       关机重启

         shutdown -h  [+10]  10分后关机
                      now    立即关机
                  -r         重启

         reboot now 重启 

         whoami  获取用户名

         文件类型： b(块设备) c(字符设备) d(目录)
                    -(普通) l(连接) s(套接字) p(管道)
         
        1. chmod 权限转换 chmod u+x sock.py
        2. 在程序中声明解释器 
        	(第一行加 #! /usr/bin/env python3)
        3. 创建程序的软连接放在环境变量目录
           进入 /usr/bin  
           sudo ln -s  /xxx/xxx/sock.py  sock
        4. 后台执行程序
           $: sock &

       通配符用法
       grep 
       df
       用户的添加删除
       tar -cjfv  压缩
           -czfv

           -xvf   解压

       ping
       ifconfig
       netstat

       vim 基本使用命令

8.  数据结构 
        
        线性表 （顺序，链式存储）
        栈 （顺序，链式）
        队列 （顺序，链式）
        二叉树 （遍历）
        递归
        快速排序

        * 双向循环链表

        * 哈希表 （散列表）

          1. 什么是哈希表，结构怎样
          2. 主要作用： 加密和快速查找
          3. 查找步骤： 目标项对应的关键字 散列地址查找
          4. 常见的key值确定方法 ： 除法取余，平方散列

        * 查找二叉树

          1. 什么是二叉查找树
          2. 二叉查找树规则
          3. 二叉查找树如何查找
          注意 ： 对于给定的数列二叉查找树的构建是不唯一的，但是按照中序进行遍历是一个有序数列

        * 平衡二叉树 （AVL）： 每个节点左右子树的高度差不超过1

          1. 红黑树

        * 哈弗曼树 （最优二叉树）： 带权路径长度最短的二叉树，称之为最优二叉树。
     
        一个节点赋予一个有意义的值称为权值，这个权值的意义自己拟定（效率，速率，流量等，以表达重要程度）

        路径长度 ： 从一个节点，到另一个节点的路径长

        带权路径长度：一个节点的权值 * 根节点到该节点的路径长度

        一个树的带权路径长度(WPL)： 这棵树所有叶子节点的带全路径长度之和

        最优二叉树的构建

        * B树 （B树  B+树）

          B树

          1. 任意非叶子节点最多有M个分支 （M>2）
          2. 根节点的分支数为 [2,M]
          3. 分支节点的儿子数 [M//2,M]
          4. 每个节点至少存放 M / 2(向上取整),至多存放 M -1 个检索关键字
          5. 非叶子节点关键字数 = 分支数 - 1
          6. 非叶子节点关键字满足 k[1] < k[2]
          7. 非叶子节点指针 p[1]指向节点的关键字小于k[1]
          8. 所有叶子节点在同一层，且叶子节点值数量小于节点关键字数量

          B+ 树

          1. 基本与B树相同 除了：

          2. 非叶子节点的子树关键字会包含父节点关键字

          3. 在叶子节点中增加了链式结构用于串联所有的叶子

          4. 所有关键字都一定会在叶子节点出现 

          	相对于B树

            1. 所有的关键字都子叶子中，数据更加稠密，使用链表将叶子串联

            2. 不可能在非叶子节点中命中关键值

            3. 更适合文件系统的索引

            优点 ： IO次数减少
                    查询稳定性更好
                    更适合范围查找

9.  网络协议
    
    * tcp udp 区别
    * tcp/ip模型
    * udp传输 （视频即时通信，广播多播组播），全靠应用程序程序进行安全性把控

    * tcp协议数据传输

      如何确定网络目标： 源IP 目标IP 协议类型 源端口 目标端口

      tcp连接 ： 虚拟连接，两者之间建立的通信约定。有发送和确认的机制进行首发消息的维护

      tcp首部结构 

      拥塞机制

      三次握手 

      	  * SYN = 1  产生随机数 seq = J，将数据包发送给服务端，然后进入等待确认的状态（SYN_SEND）

      	  * 服务端看SYN=1直到客户端要连接，将SYN和ACK位置1， 产生一个随机值 seq = K ,ack = J+1 发给客户端,进入(SYN_RCVD)

      	  * 客户端 检查 ack 是否等于J + 1,ACK是否等于1
      	  如果是将ACK置1 ack = K + 1,将数据报发送给服务端，服务端收到后会检查ACK是否等于1
      	  ack = K + 1，如果是连接成功。服务端客户端进入ESTABLISHED状态

    四次挥手
          * 主动 发送FIN置1 请求断开 ，进入 FIN_WAIT_1状态
          * 被动 发送 ACK置1 ,并且确认序号为收到序号+1给另一端，进入CLOSE_WAIT状态 
          * 被动 FIN置1 发送给主动端，LAST_ACK状态
          * 主动 收到FIN为1后，进入TIME_WAIT状态，发送ACK置1给被动端，确认序列号+1.被动段收到后进入CLOSED状态

10. HTTP协议
    
    * 请求响应格式
    * 请求类型，每个类型干什么
    * URL 格式
    * 常见响应码

      200   204
      301   302  
      404   401   403 
      500  502   503 

    * 请求头

      Cache-Control: 指定缓冲机制
      Accept：MIME 接收数据的类型
      Accept-Encoding: 编码方式
      Accept-Language : 语言 
      Accept-Charset: 浏览器字符集
      User-Agent： 浏览器
      Content-Type： 数据类型 
      Host
      Cookie
      Content-Length

    * 响应头

      Date ： 时间
      Allow： 支持的请求方法
      Set-Cookie ： 将Cookie发送到浏览器
      Content-Type： 响应数据类型
      Content-Length: 正文长度
      Server: 服务器信息
      Location : 重定向位置

11. 多线程拷贝一个大文件 （4G），运用多线程拷贝到另一个目录下

    * 将线程等分为若干份，每个线程复制一份
    * 每个线程中独立打来 读 写的文件
    * 通过seek确定文件偏移，进行读写

12. epoll 和 select poll的区别
    
    * epoll为什么效率高
    * 什么是边缘触发，什么是水平触发

      register(connfd,EPOLLIN|EPOLLET)


13. mysql数据库 

    * 数据库三范式
    * 关联查询 inner join  left join  right join
    * 数据库外键关联作用 为了保证数据完整性的约束
    * 子查询
    * 事务 锁
    * 索引 （什么时候创建索引，索引的影响， explian）
    * 引擎 基本了解 
    * 索引内部结构
    * 优化 （语句优化，索引优化）
    * 安全 （sql注入，大量数据表结构修改）


